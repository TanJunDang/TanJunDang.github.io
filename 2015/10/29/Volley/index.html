<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Volley跟Async-http的封装 | YimSam-Tam 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="YimSam-Tam">
    
    

    <meta name="description" content="Volley的基础compile &amp;apos;com.mcxiaoke.volley:library:1.0.19&amp;apos;

Volley有get 、post等方式请求数据。
Volley可以建立、取消请求队列。
把请求加入请求队列即可完成请求。

作用：

封装网络请求类，使请求代码量减少。
大大提高性能（反正很厉害就对了）。

使用示例：
1. RequestQueue queue = V">
<meta property="og:type" content="article">
<meta property="og:title" content="Volley跟Async-http的封装 | YimSam-Tam">
<meta property="og:url" content="YimSamTam.github.io/2015/10/29/Volley/index.html">
<meta property="og:site_name" content="YimSam-Tam">
<meta property="og:description" content="Volley的基础compile &amp;apos;com.mcxiaoke.volley:library:1.0.19&amp;apos;

Volley有get 、post等方式请求数据。
Volley可以建立、取消请求队列。
把请求加入请求队列即可完成请求。

作用：

封装网络请求类，使请求代码量减少。
大大提高性能（反正很厉害就对了）。

使用示例：
1. RequestQueue queue = V">
<meta property="og:image" content="http://imglf.nosdn.127.net/img/U05xRllGZk4zNVBrbzBDSHg1S3V0Q0FQaWNiTW1jaGhFSy9kVVZIZHNUQ1dmR3RKajJkKzdBPT0.png?imageView&thumbnail=500x0&quality=96&stripmeta=0&type=jpg">
<meta property="og:updated_time" content="2016-04-05T09:05:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Volley跟Async-http的封装 | YimSam-Tam">
<meta name="twitter:description" content="Volley的基础compile &amp;apos;com.mcxiaoke.volley:library:1.0.19&amp;apos;

Volley有get 、post等方式请求数据。
Volley可以建立、取消请求队列。
把请求加入请求队列即可完成请求。

作用：

封装网络请求类，使请求代码量减少。
大大提高性能（反正很厉害就对了）。

使用示例：
1. RequestQueue queue = V">
<meta name="twitter:image" content="http://imglf.nosdn.127.net/img/U05xRllGZk4zNVBrbzBDSHg1S3V0Q0FQaWNiTW1jaGhFSy9kVVZIZHNUQ1dmR3RKajJkKzdBPT0.png?imageView&thumbnail=500x0&quality=96&stripmeta=0&type=jpg">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">YimSam-Tam</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          程序猿
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Volley跟Async-http的封装</h1>

    

    <div class="post-meta">
      <time datetime="2015-10-29" class="post-meta__date date">2015-10-29</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/Async-http/">Async-http</a>, <a class="tags-link" href="/tags/Volley/">Volley</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h4 id="Volley的基础"><a href="#Volley的基础" class="headerlink" title="Volley的基础"></a>Volley的基础</h4><pre><code>compile &apos;com.mcxiaoke.volley:library:1.0.19&apos;
</code></pre><ol>
<li>Volley有get 、post等方式请求数据。</li>
<li>Volley可以建立、取消请求队列。</li>
<li>把请求加入请求队列即可完成请求。</li>
</ol>
<p>作用：</p>
<ul>
<li>封装网络请求类，使请求代码量减少。</li>
<li>大大提高性能（反正很厉害就对了）。</li>
</ul>
<p>使用示例：</p>
<pre><code>1. RequestQueue queue = Volley.newRequestQueue(context)//创建一个队列
2. StringRequest jr  = new StringRequest(请求方式get/post，请求url，成功监听器，失败监听器)//创建一种请求方式
3. queue.add(jr);//加入到队列
</code></pre><a id="more"></a>
<p>请求类型：  </p>
<ul>
<li>JsonRequest  </li>
<li>StringRequest</li>
<li>ImageRequest </li>
<li>JsonArrayRequest</li>
<li>JsonObjectRequest</li>
<li>ClearCacheRequest</li>
</ul>
<h4 id="Async-Http的基础"><a href="#Async-Http的基础" class="headerlink" title="Async-Http的基础"></a>Async-Http的基础</h4><pre><code>compile &apos;com.loopj.android:android-async-http:1.4.8&apos;
</code></pre><ol>
<li>Async-http有get、post等方式请求数据。</li>
<li>直接通过AsyncHttpClient对象调用get、post即可完成请求。</li>
</ol>
<p>作用：</p>
<ul>
<li>封装网络请求，使请求代码量减少。</li>
<li>可以用于上传文件、下载文件。</li>
</ul>
<p>使用示例：</p>
<pre><code>1.  AsyncHttpClient client = new AsyncHttpClient();
2.  client.post(url,一个回调函数)；
</code></pre><h4 id="Volley跟Async-http的封装对比"><a href="#Volley跟Async-http的封装对比" class="headerlink" title="Volley跟Async-http的封装对比"></a>Volley跟Async-http的封装对比</h4><p>先看Async-http的封装 </p>
<p>优点：</p>
<ul>
<li>封装简单</li>
<li>不用自己写请求类</li>
</ul>
<p>缺点：</p>
<ul>
<li>没有解决同一个页面多种请求的问题</li>
</ul>
<pre><code>    //封装请求类
    public class HttpRequestUtils {
        private static AsyncHttpClient client = new AsyncHttpClient();
        public static void httpGet(String url, HttpCallBack callBack) {
            client.get(url, callBack);
    }

        public static void httpPost(String url, RequestParams params, HttpCallBack callBack) {
            client.post(url, params, callBack);
    }
}


    //由于请求服务器后，要对返回的数据进行处理，所以要定义两个抽象方法，否则 就会默认执行下述重写的方法onSucess

    Http业务的回调接口
    public abstract class HttpCallBack extends AsyncHttpResponseHandler {
        @Override
        public void onSuccess(int statusCode, Header[] headers, byte[] responseBody)     {
                onRequestSuccess(responseBody);
        }

        @Override
        public void onFailure(int statusCode, Header[] headers, byte[] responseBody,     Throwable error) {
            onRequestFailure(error);
        }
        public abstract void onRequestSuccess(String result);//定义两个抽象函数
        public abstract void onRequestFailure(Throwable error);
}
</code></pre><p>下面是Volley的封装</p>
<p>优点：</p>
<ul>
<li>可以解决同一页面多种请求</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要自己写请求类</li>
</ul>
<pre><code>//Http业务的回调接口
public interface HttpCallBack {
    public abstract void onSuccess(String result, long flag);
    public abstract void onFailure(String error, long flag);
}

//封装请求工具类
public class HttpReqUtils {
    private static HttpReqUtils httpReqUtils;
    private static RequestQueue queue;
    private AtomicLong mHttpCount = new AtomicLong(0); //用于实现同一页面多种请求的标识

    //单例模式工具初始化
    public static HttpReqUtils getInstance(Context context) {
        if (httpReqUtils == null) {
        httpReqUtils = new HttpReqUtils();
        queue = Volley.newRequestQueue(context);
    }
    return httpReqUtils;
    }


    public long asyncPost(String url, final HttpCallBack httpCallBack) {
        final long flag = mHttpCount.incrementAndGet(); //每次请求一次业务，该标识就自增1，该返回标识用于判断是哪个业务做的请求
        StringRequest stringRequest = new StringRequest(Request.Method.POST, url,     new Response.Listener&lt;String&gt;() {
            @Override
            public void onResponse(String response) {
                httpCallBack.onSuccess(response, flag);
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
                String errorMsg = error.getMessage();
                httpCallBack.onFailure(errorMsg, flag);
            }
        });
        queue.add(stringRequest);
        return flag;
        }
}
</code></pre><p>综合上述：</p>
<ul>
<li>应该封装Volley而不是Async-http</li>
<li>Async-http应该用于封装文件上传、下载</li>
</ul>
<h3 id="如何修改已封装好的请求函数"><a href="#如何修改已封装好的请求函数" class="headerlink" title="如何修改已封装好的请求函数"></a>如何修改已封装好的请求函数</h3><p>背景：</p>
<p>调用第三方的请求函数，需要调用其回调函数。我想用自己定义的回调函数，该怎么办？</p>
<pre><code>public static long onGetTodayMoviesMsg(Context context, int cityid, DataCallBack callBack) {
    Parameters params = new Parameters();
    params.add(&quot;cityid&quot;, cityid);
    JuheData.executeWithAPI(context, 42, TODAY_MOVIE_MSG, JuheData.GET, params, callBack);
    return flag;
}
// 第三方的回调函数是DataCallBack，自定义的HttpCallBack
</code></pre><p>思路：</p>
<ol>
<li><p>自定义一个请求函数，传入自定义的Callback参数。</p>
<pre><code>public static void CustomExecuteWithApi(Context context, int did, String uri, String method, Parameters params, final HttpCallBack mCallback) {
DataCallback callback = null;
JuheData.executeWithAPI(context, did, uri, method, params, callBack);
}
</code></pre></li>
<li><p>创建第三方Callback的对象,重新其方法。</p>
</li>
</ol>
<pre><code>    public static void CustomExecuteWithApi(Context context, int did, String uri, String method, Parameters params, final HttpCallBack mCallback) {
    DataCallBack callBack = new DataCallBack() {
        @Override
        public void onSuccess(int i, String s) {
            //此处调用自定义callback的函数
            mCallback.onSuccess(s, FLAG_GET_CITY_MSG);
        }

        @Override
        public void onFinish() {

        }

        @Override
        public void onFailure(int i, String s, Throwable throwable) {
            //此处调用自定义callback的函数
            mCallback.onFailure(s, FLAG_GET_CITY_MSG);
        }
    };
    JuheData.executeWithAPI(context, did, uri, method, params, callBack);
}
</code></pre><p>总结：</p>
<ul>
<li>对第三方请求方法再次封装。</li>
</ul>
<h3 id="请求Flag的理解"><a href="#请求Flag的理解" class="headerlink" title="请求Flag的理解"></a>请求Flag的理解</h3><p>背景：</p>
<p>由于一个界面可能会请求多条协议，所以要区分是哪条协议返回的结果，就必须要一个标识来判断。</p>
<p>实现：</p>
<ul>
<li>请求协议返回的标识跟实现接口返回的标识是一致的。</li>
<li>可以利用递增函数实现，每个数字代表一个协议。</li>
</ul>
<pre><code>private static AtomicLong atomicLong = new AtomicLong(0); //初始化从0开始递增
</code></pre><p><img src="http://imglf.nosdn.127.net/img/U05xRllGZk4zNVBrbzBDSHg1S3V0Q0FQaWNiTW1jaGhFSy9kVVZIZHNUQ1dmR3RKajJkKzdBPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
